<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Art Gallery</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; overflow: hidden; background: #000; cursor: default; touch-action: none; }
        #canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            flex-direction: column;
            color: white;
        }
        
        #loading-screen.hidden { display: none; }
        
        .loader {
            border: 8px solid #333;
            border-top: 8px solid #4CAF50;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #loading-text {
            font-size: 18px;
            margin-top: 10px;
        }
        
        #info {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 10px;
            font-size: 14px; max-width: 300px; z-index: 10;
            transition: all 0.3s ease;
        }
        #info.minimized {
            padding: 8px;
            max-width: 120px;
        }
        #info.minimized .info-content { display: none; }
        #info h3 { margin-bottom: 8px; }
        
        #minimize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            line-height: 20px;
            padding: 0;
        }
        #minimize-btn:hover { background: rgba(255, 255, 255, 0.3); }
        
        #artwork-detail {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: white; padding: 20px; border-radius: 15px;
            max-width: 90vw; 
            max-height: 90vh;
            width: auto;
            height: auto;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            transition: transform 0.3s ease; z-index: 100;
            -webkit-overflow-scrolling: touch;
        }
        #artwork-detail.active { transform: translate(-50%, -50%) scale(1); }
        #artwork-detail h2 { margin-bottom: 10px; color: #333; font-size: clamp(18px, 3vw, 24px); }
        #artwork-detail p { margin-bottom: 8px; color: #666; font-size: clamp(12px, 2vw, 16px); }
        #artwork-detail img { 
            max-width: 100%; 
            max-height: 60vh;
            width: auto;
            height: auto;
            object-fit: contain;
            margin: 15px 0; 
            border-radius: 8px;
            cursor: pointer;
        }
        #close-btn {
            position: absolute; top: 15px; right: 15px;
            background: #e74c3c; color: white; border: none;
            width: 30px; height: 30px; border-radius: 50%;
            cursor: pointer; font-size: 18px; line-height: 30px;
            z-index: 101;
        }
        #close-btn:hover { background: #c0392b; }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        #minimap.mobile-mode {
            bottom: auto;
            top: 20px;
            left: auto;
            right: 20px;
            transform: none;
            width: 80px;
            height: 80px;
        }

        .mobile-controls {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 99;
        }
        .mobile-controls.active { 
            display: block;
        }
        
        .joystick {
            position: fixed;
            width: 120px;
            height: 120px;
            background: rgba(100, 150, 255, 0.4);
            border: 4px solid rgba(100, 150, 255, 0.8);
            border-radius: 50%;
            pointer-events: all;
            z-index: 100;
        }
        #joystick-left { bottom: 40px; left: 40px; }
        #joystick-right { bottom: 40px; right: 40px; }
        
        .joystick-inner {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid rgba(100, 150, 255, 1);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .control-btn:hover { background: rgba(0, 0, 0, 0.9); }

        #image-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        #image-overlay.active { display: flex; }
        #image-overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loader"></div>
        <div id="loading-text">Loading gallery...</div>
    </div>

    <canvas id="canvas"></canvas>
    
    <div id="info">
        <button id="minimize-btn" title="Minimize">−</button>
        <div class="info-content">
            <h3>Controls</h3>
            <p id="desktop-controls"><strong>WASD/Arrows</strong> - Move<br><strong>Mouse Edges</strong> - Look<br><strong>Click Frame</strong> - Info</p>
            <p id="mobile-controls-text" style="display:none;"><strong>Left Stick</strong> - Move<br><strong>Right Stick</strong> - Look<br><strong>Tap Frame</strong> - Info</p>
            <button id="mode-toggle-btn" class="control-btn" style="margin-top: 10px; width: 100%;">Switch to Mobile</button>
            <button id="fullscreen-btn" class="control-btn" style="margin-top: 5px; width: 100%;">Fullscreen</button>
        </div>
    </div>
    
    <canvas id="minimap"></canvas>
    
    <div class="mobile-controls">
        <div id="joystick-left" class="joystick">
            <div class="joystick-inner"></div>
        </div>
        <div id="joystick-right" class="joystick">
            <div class="joystick-inner"></div>
        </div>
    </div>
    
    <div id="artwork-detail">
        <button id="close-btn">×</button>
        <h2 id="detail-title"></h2>
        <p id="detail-artist"></p>
        <p id="detail-year"></p>
        <img id="detail-image" src="" alt="" style="display: none;">
        <p id="detail-description"></p>
    </div>

    <div id="image-overlay">
        <img id="enlarged-image" src="" alt="">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // Configuration
        const CONFIG = {
            descriptionsFile: './descriptions.xlsx', // Your Excel file
            imagesFolder: './images/',               // Your images folder
            imageExtensions: ['jpg', 'jpeg', 'png', 'JPG', 'JPEG', 'PNG']
        };

        let galleryData = {
            pieces: []
        };

        // Load Excel file with descriptions
        async function loadDescriptions() {
            try {
                const response = await fetch(CONFIG.descriptionsFile);
                const arrayBuffer = await response.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                
                // Get first sheet
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const data = XLSX.utils.sheet_to_json(firstSheet, { defval: '' });
                
                console.log('Excel data loaded:', data);
                
                if (data.length === 0) {
                    throw new Error('Excel file is empty');
                }
                
                // Map Excel data to gallery pieces - try multiple possible column names
                data.forEach(row => {
                    const piece = {
                        id: row['ID'] || row['id'] || row['Piece'] || row['piece'] || row['Number'] || row['number'] || row['#'],
                        title: row['Title'] || row['title'] || row['Name'] || row['name'] || 'Untitled',
                        artist: row['Artist'] || row['artist'] || row['Creator'] || row['creator'] || 'Unknown Artist',
                        year: String(row['Year'] || row['year'] || row['Date'] || row['date'] || ''),
                        description: row['Description'] || row['description'] || row['Details'] || row['details'] || '',
                        has3DModel: true
                    };
                    
                    if (piece.id) {
                        galleryData.pieces.push(piece);
                    }
                });
                
                // Sort by ID
                galleryData.pieces.sort((a, b) => a.id - b.id);
                
                console.log(`✓ Loaded ${galleryData.pieces.length} piece descriptions from Excel`);
                return true;
            } catch (error) {
                console.error('Error loading descriptions:', error);
                console.log('Using default placeholder descriptions instead');
                // Create default pieces if Excel fails
                for (let i = 1; i <= 20; i++) {
                    galleryData.pieces.push({
                        id: i,
                        title: `Art Piece ${i}`,
                        artist: 'Artist Name',
                        year: '2024',
                        description: `Description for art piece ${i}. Upload descriptions.xlsx with columns: ID, Title, Artist, Year, Description`,
                        has3DModel: true
                    });
                }
                return false;
            }
        }

        // Preload all images
        const loadedImages = {};
        async function preloadImages() {
            const imagePromises = [];
            
            for (let piece of galleryData.pieces) {
                const promise = new Promise((resolve) => {
                    let loaded = false;
                    let extIndex = 0;
                    
                    function tryNextExtension() {
                        if (extIndex >= CONFIG.imageExtensions.length) {
                            console.log(`⚠ Image not found for piece ${piece.id}`);
                            resolve();
                            return;
                        }
                        
                        const ext = CONFIG.imageExtensions[extIndex];
                        const img = new Image();
                        
                        img.onload = function() {
                            loadedImages[piece.id] = img;
                            console.log(`✓ Loaded image for piece ${piece.id}`);
                            resolve();
                        };
                        
                        img.onerror = function() {
                            extIndex++;
                            tryNextExtension();
                        };
                        
                        img.src = `${CONFIG.imagesFolder}piece${piece.id}.${ext}`;
                    }
                    
                    tryNextExtension();
                });
                
                imagePromises.push(promise);
            }
            
            await Promise.all(imagePromises);
            console.log(`✓ Preloaded ${Object.keys(loadedImages).length} images`);
        }

        // Initialize gallery
        async function init() {
            document.getElementById('loading-text').textContent = 'Loading descriptions...';
            await loadDescriptions();
            
            document.getElementById('loading-text').textContent = 'Loading images...';
            await preloadImages();
            
            document.getElementById('loading-text').textContent = 'Building gallery...';
            await new Promise(resolve => setTimeout(resolve, 500));
            
            document.getElementById('loading-screen').classList.add('hidden');
            initGallery();
        }

        function initGallery() {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1612);
            scene.fog = new THREE.Fog(0x1a1612, 25, 60);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 10);

            const canvas = document.getElementById('canvas');
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Elegant museum lighting - warm and dramatic
            const ambient = new THREE.AmbientLight(0xffd4a8, 0.15);
            scene.add(ambient);

            // Main chandelier center light
            const centerLight = new THREE.PointLight(0xfff4d6, 2.5, 35);
            centerLight.position.set(0, 5.0, 0);
            centerLight.castShadow = true;
            centerLight.shadow.mapSize.width = 2048;
            centerLight.shadow.mapSize.height = 2048;
            centerLight.shadow.radius = 4;
            scene.add(centerLight);

            // Warm corner accent lights
            const cornerPositions = [
                [15, 13], [-15, -13], [15, -13], [-15, 13]
            ];
            
            cornerPositions.forEach(([x, z]) => {
                const cornerLight = new THREE.SpotLight(0xffa860, 1.2, 30);
                cornerLight.position.set(x, 5, z);
                cornerLight.angle = Math.PI / 3;
                cornerLight.penumbra = 0.7;
                cornerLight.target.position.set(x * 0.7, 0, z * 0.7);
                scene.add(cornerLight);
                scene.add(cornerLight.target);
            });
            
            // Subtle overall fill from above
            const directionalLight = new THREE.DirectionalLight(0xffd9a8, 0.25);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // Floor - Rich dark hardwood with realistic grain
            const floorCanvas = document.createElement('canvas');
            floorCanvas.width = 1024;
            floorCanvas.height = 1024;
            const floorCtx = floorCanvas.getContext('2d');
            
            // Create wood grain pattern
            const gradient = floorCtx.createLinearGradient(0, 0, 1024, 0);
            gradient.addColorStop(0, '#2d2520');
            gradient.addColorStop(0.3, '#3a2f28');
            gradient.addColorStop(0.5, '#2d2520');
            gradient.addColorStop(0.7, '#3a2f28');
            gradient.addColorStop(1, '#2d2520');
            floorCtx.fillStyle = gradient;
            floorCtx.fillRect(0, 0, 1024, 1024);
            
            // Add wood grain details
            for (let i = 0; i < 200; i++) {
                floorCtx.strokeStyle = `rgba(25, 20, 18, ${0.1 + Math.random() * 0.15})`;
                floorCtx.lineWidth = Math.random() * 2;
                floorCtx.beginPath();
                const y = Math.random() * 1024;
                floorCtx.moveTo(0, y);
                floorCtx.bezierCurveTo(
                    256 + Math.random() * 100, y + (Math.random() - 0.5) * 20,
                    512 + Math.random() * 100, y + (Math.random() - 0.5) * 20,
                    1024, y + (Math.random() - 0.5) * 10
                );
                floorCtx.stroke();
            }
            
            // Add subtle highlights for polish
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 1024;
                floorCtx.fillStyle = `rgba(80, 70, 60, ${Math.random() * 0.08})`;
                floorCtx.fillRect(x, y, 1, 1);
            }
            
            // Add plank separations
            for (let i = 0; i < 40; i++) {
                const x = i * 25.6;
                floorCtx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
                floorCtx.lineWidth = 1.5;
                floorCtx.beginPath();
                floorCtx.moveTo(x, 0);
                floorCtx.lineTo(x, 1024);
                floorCtx.stroke();
            }
            
            const floorTexture = new THREE.CanvasTexture(floorCanvas);
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(10, 10);
            
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(40, 40, 40, 40),
                new THREE.MeshStandardMaterial({ 
                    map: floorTexture,
                    color: 0x2d2520,
                    roughness: 0.35,
                    metalness: 0.15,
                    envMapIntensity: 0.4
                })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Ceiling - Deep matte black
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(40, 40, 5, 5),
                new THREE.MeshStandardMaterial({ 
                    color: 0x050505,
                    roughness: 0.95,
                    metalness: 0.0
                })
            );
            ceiling.position.y = 6;
            ceiling.rotation.x = Math.PI / 2;
            scene.add(ceiling);
            
            // Add ceiling beams for architectural interest
            const beamMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.8,
                metalness: 0.1
            });
            
            for (let i = -3; i <= 3; i++) {
                const beam = new THREE.Mesh(
                    new THREE.BoxGeometry(40, 0.3, 0.4),
                    beamMaterial
                );
                beam.position.set(0, 5.7, i * 6);
                beam.castShadow = true;
                scene.add(beam);
            }

            // Modern elegant chandelier - suspended sculpture
            // Main ring structure
            const chandelierRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.8, 0.12, 16, 48),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    roughness: 0.15,
                    metalness: 0.95,
                    emissive: 0x4a3820,
                    emissiveIntensity: 0.2
                })
            );
            chandelierRing.position.set(0, 5.2, 0);
            chandelierRing.rotation.x = Math.PI / 2;
            scene.add(chandelierRing);
            
            // Inner decorative elements
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const x = Math.cos(angle) * 1.5;
                const z = Math.sin(angle) * 1.5;
                
                // Crystal pendant lights
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(0.08, 0.4, 6),
                    new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.05,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.9,
                        emissive: 0xffffee,
                        emissiveIntensity: 0.6
                    })
                );
                crystal.position.set(x, 4.9, z);
                scene.add(crystal);
                
                // Small accent lights
                const accentLight = new THREE.PointLight(0xfff4d6, 0.8, 5);
                accentLight.position.set(x, 4.9, z);
                scene.add(accentLight);
            }
            
            // Central glow disc
            const lightDisc = new THREE.Mesh(
                new THREE.CircleGeometry(1.3, 64),
                new THREE.MeshStandardMaterial({ 
                    color: 0xfff8e8,
                    emissive: 0xfff8e8,
                    emissiveIntensity: 0.8,
                    roughness: 0.1,
                    transparent: true,
                    opacity: 0.7
                })
            );
            lightDisc.position.set(0, 5.15, 0);
            lightDisc.rotation.x = -Math.PI / 2;
            scene.add(lightDisc);

            // Walls - Rich deep burgundy velvet texture
            const wallCanvas = document.createElement('canvas');
            wallCanvas.width = 512;
            wallCanvas.height = 512;
            const wallCtx = wallCanvas.getContext('2d');
            
            // Deep burgundy base
            const wallGradient = wallCtx.createLinearGradient(0, 0, 512, 512);
            wallGradient.addColorStop(0, '#3d2228');
            wallGradient.addColorStop(0.5, '#4a2630');
            wallGradient.addColorStop(1, '#3d2228');
            wallCtx.fillStyle = wallGradient;
            wallCtx.fillRect(0, 0, 512, 512);
            
            // Velvet-like texture with subtle sheen variation
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const brightness = 40 + Math.random() * 30;
                const alpha = Math.random() * 0.06;
                wallCtx.fillStyle = `rgba(${brightness + 30}, ${brightness}, ${brightness + 10}, ${alpha})`;
                wallCtx.fillRect(x, y, Math.random() * 1.5, Math.random() * 1.5);
            }
            
            // Add subtle fabric weave pattern
            for (let y = 0; y < 512; y += 4) {
                wallCtx.strokeStyle = `rgba(20, 10, 15, ${0.03 + Math.random() * 0.03})`;
                wallCtx.lineWidth = 0.5;
                wallCtx.beginPath();
                wallCtx.moveTo(0, y);
                wallCtx.lineTo(512, y);
                wallCtx.stroke();
            }
            
            const wallTexture = new THREE.CanvasTexture(wallCanvas);
            wallTexture.wrapS = THREE.RepeatWrapping;
            wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(3, 3);
            
            const wallMat = new THREE.MeshStandardMaterial({ 
                map: wallTexture,
                color: 0x3d2228,
                roughness: 0.92,
                metalness: 0.02
            });

            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 6), wallMat);
            backWall.position.set(0, 3, -20);
            backWall.receiveShadow = true;
            scene.add(backWall);

            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 6), wallMat);
            leftWall.position.set(-20, 3, 0);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 6), wallMat);
            rightWall.position.set(20, 3, 0);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 6), wallMat);
            frontWall.position.set(0, 3, 20);
            frontWall.rotation.y = Math.PI;
            frontWall.receiveShadow = true;
            scene.add(frontWall);

            const artworkMeshes = [];

            // Enhanced materials - White marble pedestals with gold trim
            const pedestalCanvas = document.createElement('canvas');
            pedestalCanvas.width = 512;
            pedestalCanvas.height = 512;
            const pedestalCtx = pedestalCanvas.getContext('2d');
            
            // White marble base
            pedestalCtx.fillStyle = '#f5f5f0';
            pedestalCtx.fillRect(0, 0, 512, 512);
            
            // Add marble veining
            for (let i = 0; i < 30; i++) {
                pedestalCtx.strokeStyle = `rgba(180, 175, 170, ${0.15 + Math.random() * 0.2})`;
                pedestalCtx.lineWidth = 1 + Math.random() * 3;
                pedestalCtx.beginPath();
                const startX = Math.random() * 512;
                const startY = Math.random() * 512;
                pedestalCtx.moveTo(startX, startY);
                for (let j = 0; j < 5; j++) {
                    pedestalCtx.lineTo(
                        startX + (Math.random() - 0.5) * 200,
                        startY + (Math.random() - 0.5) * 200
                    );
                }
                pedestalCtx.stroke();
            }
            
            // Add subtle texture
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const brightness = 230 + Math.random() * 25;
                const alpha = Math.random() * 0.08;
                pedestalCtx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness-5}, ${alpha})`;
                pedestalCtx.fillRect(x, y, 1, 1);
            }
            
            const pedestalTexture = new THREE.CanvasTexture(pedestalCanvas);
            pedestalTexture.wrapS = THREE.RepeatWrapping;
            pedestalTexture.wrapT = THREE.RepeatWrapping;
            
            const pedestalMat = new THREE.MeshStandardMaterial({ 
                map: pedestalTexture,
                color: 0xf5f5f0,
                roughness: 0.25,
                metalness: 0.1
            });
            
            // Create beveled pedestal geometry instead of sharp box
            function createBeveledPedestal() {
                const shape = new THREE.Shape();
                const w = 0.6, h = 0.5;
                shape.moveTo(-w, -h);
                shape.lineTo(w, -h);
                shape.lineTo(w, h);
                shape.lineTo(-w, h);
                shape.lineTo(-w, -h);
                
                const extrudeSettings = {
                    depth: 0.3,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.02,
                    bevelSegments: 3
                };
                
                return new THREE.ExtrudeGeometry(shape, extrudeSettings);
            }
            const artMat1 = new THREE.MeshStandardMaterial({ color: 0x3a5f7a, roughness: 0.7 });
            const artMat2 = new THREE.MeshStandardMaterial({ color: 0xb08560, roughness: 0.7 });
            const artMat3 = new THREE.MeshStandardMaterial({ color: 0x5a4d42, roughness: 0.7 });
            const artMaterials = [artMat1, artMat2, artMat3];

            // Rectangular pedestal geometry - long side parallel to wall
            const pedestalGeo = new THREE.BoxGeometry(1.2, 1, 0.6); // Width, Height, Depth
            const artGeo = new THREE.BoxGeometry(0.6, 0.6, 0.15);

            // Distribute pieces across walls - 5 pieces per wall, clockwise
            const totalPieces = galleryData.pieces.length;
            const positions = [];
            
            const piecesPerWall = 5;
            let backWallCount = Math.min(piecesPerWall, totalPieces);
            let rightWallCount = Math.min(piecesPerWall, Math.max(0, totalPieces - backWallCount));
            let frontWallCount = Math.min(piecesPerWall, Math.max(0, totalPieces - backWallCount - rightWallCount));
            let leftWallCount = Math.max(0, totalPieces - backWallCount - rightWallCount - frontWallCount);
            
            // Back wall (Z = -19) - piece 1 starts here
            for (let i = 0; i < backWallCount; i++) {
                const spacing = 40 / (backWallCount + 1);
                positions.push({ x: -20 + spacing * (i + 1), z: -19, wall: 'back' });
            }
            
            // Right wall (X = 19) - clockwise next
            for (let i = 0; i < rightWallCount; i++) {
                const spacing = 40 / (rightWallCount + 1);
                positions.push({ x: 19, z: -20 + spacing * (i + 1), wall: 'right' });
            }
            
            // Front wall (Z = 19) - clockwise next
            for (let i = 0; i < frontWallCount; i++) {
                const spacing = 40 / (frontWallCount + 1);
                positions.push({ x: 20 - spacing * (i + 1), z: 19, wall: 'front' });
            }
            
            // Left wall (X = -19) - clockwise last
            for (let i = 0; i < leftWallCount; i++) {
                const spacing = 40 / (leftWallCount + 1);
                positions.push({ x: -19, z: 20 - spacing * (i + 1), wall: 'left' });
            }

            positions.forEach((pos, i) => {
                if (i >= galleryData.pieces.length) return;
                
                const pieceData = galleryData.pieces[i];
                const group = new THREE.Group();
                
                // Determine rotation to face center of room
                let rotationY = 0;
                if (pos.wall === 'back') {
                    rotationY = 0; // Face forward (toward center)
                } else if (pos.wall === 'front') {
                    rotationY = Math.PI; // Face backward (toward center)
                } else if (pos.wall === 'left') {
                    rotationY = Math.PI / 2; // Face right (toward center)
                } else if (pos.wall === 'right') {
                    rotationY = -Math.PI / 2; // Face left (toward center)
                }
                
                // Pedestal - elegant white marble with gold base trim
                const pedestalGeo = new THREE.BoxGeometry(1.2, 1, 0.6, 4, 4, 4);
                // Round the edges by modifying geometry
                const positionAttribute = pedestalGeo.getAttribute('position');
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = positionAttribute.getX(i);
                    const y = positionAttribute.getY(i);
                    const z = positionAttribute.getZ(i);
                    
                    // Soften edges
                    const edgeFactor = 0.95;
                    if (Math.abs(x) > 0.5) positionAttribute.setX(i, x * edgeFactor);
                    if (Math.abs(z) > 0.25) positionAttribute.setZ(i, z * edgeFactor);
                }
                pedestalGeo.computeVertexNormals();
                
                const pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
                pedestal.position.y = 0.5;
                pedestal.rotation.y = rotationY;
                pedestal.castShadow = true;
                pedestal.receiveShadow = true;
                group.add(pedestal);
                
                // Gold trim at base
                const goldTrim = new THREE.Mesh(
                    new THREE.BoxGeometry(1.25, 0.08, 0.65),
                    new THREE.MeshStandardMaterial({
                        color: 0xd4af37,
                        roughness: 0.15,
                        metalness: 0.95,
                        emissive: 0x4a3820,
                        emissiveIntensity: 0.1
                    })
                );
                goldTrim.position.y = 0.04;
                goldTrim.rotation.y = rotationY;
                group.add(goldTrim);

                // Number text on pedestal - positioned based on which wall (always faces center)
                const numberCanvas = document.createElement('canvas');
                numberCanvas.width = 256;
                numberCanvas.height = 256;
                const numberCtx = numberCanvas.getContext('2d');
                numberCtx.clearRect(0, 0, 256, 256);
                numberCtx.fillStyle = '#FFD700'; // Gold color
                numberCtx.font = 'bold 120px Arial';
                numberCtx.textAlign = 'center';
                numberCtx.textBaseline = 'middle';
                numberCtx.fillText(pieceData.id.toString(), 128, 128);
                
                const numberTexture = new THREE.CanvasTexture(numberCanvas);
                numberTexture.transparent = true;
                const numberPlate = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 0.3),
                    new THREE.MeshStandardMaterial({ 
                        map: numberTexture,
                        transparent: true,
                        opacity: 1.0
                    })
                );
                
                // Position based on wall - upper left corner of the face that points to center
                let numberX = 0, numberZ = 0;
                if (pos.wall === 'back') {
                    // Face forward toward center, number on upper left from viewer's perspective
                    numberX = -0.4;  // Left side
                    numberZ = 0.31;  // Front face
                } else if (pos.wall === 'front') {
                    // Face backward toward center
                    numberX = 0.4;   // Left side (reversed because facing opposite)
                    numberZ = -0.31; // Back face
                } else if (pos.wall === 'left') {
                    // Face right toward center
                    numberX = 0.31;  // Right face
                    numberZ = -0.4;  // Left side
                } else if (pos.wall === 'right') {
                    // Face left toward center
                    numberX = -0.31; // Left face
                    numberZ = 0.4;   // Right side
                }
                
                numberPlate.position.set(numberX, 0.7, numberZ); // Upper position
                numberPlate.rotation.y = rotationY;
                group.add(numberPlate);

                // Art piece on top - also facing center
                let artPiece;
                if (pieceData.has3DModel) {
                    // Apply circular disc rendering to ALL pieces (like piece #1)
                    if (loadedImages[pieceData.id]) {
                        // Create THIN CYLINDER for circular art - standing UPRIGHT
                        const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.02, 64); // radius 0.5m, thin 2cm
                        const discTexture = new THREE.Texture(loadedImages[pieceData.id]);
                        discTexture.needsUpdate = true;
                        
                        const materials = [
                            new THREE.MeshStandardMaterial({ color: 0x8B7355 }), // side edge
                            new THREE.MeshStandardMaterial({ map: discTexture }), // top face
                            new THREE.MeshStandardMaterial({ map: discTexture })  // bottom face
                        ];
                        
                        const art = new THREE.Mesh(cylinderGeometry, materials);
                        art.position.y = 1.5;
                        
                        // First tip sideways so the face shows (not the edge)
                        art.rotation.z = Math.PI / 2;
                        // Then rotate to face the CENTER of the room
                        art.rotation.y = rotationY + Math.PI / 2; // Add 90° to correct orientation
                        
                        art.castShadow = true;
                        group.add(art);
                        artPiece = art;
                        
                        // Add DEDICATED BRIGHT SPOTLIGHT for each piece
                        const artSpotlight = new THREE.SpotLight(0xffffff, 3.0); // Bright white light
                        artSpotlight.position.set(pos.x, 5, pos.z);
                        artSpotlight.target = art;
                        artSpotlight.angle = Math.PI / 10; // Focused beam
                        artSpotlight.penumbra = 0.3;
                        artSpotlight.castShadow = true;
                        scene.add(artSpotlight);
                    } else {
                        // Regular box for pieces without images
                        const art = new THREE.Mesh(artGeo, artMaterials[i % 3]);
                        art.position.y = 1.2;
                        art.rotation.y = rotationY;
                        art.castShadow = true;
                        group.add(art);
                        artPiece = art;
                    }
                } else {
                    const invisibleBox = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.6, 0.15),
                        new THREE.MeshBasicMaterial({ visible: false })
                    );
                    invisibleBox.position.y = 1.2;
                    invisibleBox.rotation.y = rotationY;
                    group.add(invisibleBox);
                    artPiece = invisibleBox;
                }

                // Clickable info area on pedestal - positioned based on which wall (always faces center)
                const infoCanvas = document.createElement('canvas');
                infoCanvas.width = 512;
                infoCanvas.height = 512;
                const infoCtx = infoCanvas.getContext('2d');
                
                // Draw the image or placeholder
                if (loadedImages[pieceData.id]) {
                    infoCtx.drawImage(loadedImages[pieceData.id], 0, 0, 512, 512);
                } else {
                    infoCtx.fillStyle = '#ffffff';
                    infoCtx.fillRect(0, 0, 512, 512);
                    infoCtx.fillStyle = '#999999';
                    infoCtx.font = '32px Arial';
                    infoCtx.textAlign = 'center';
                    infoCtx.fillText('No Image', 256, 220);
                    infoCtx.font = '24px Arial';
                    infoCtx.fillText(`Piece ${pieceData.id}`, 256, 280);
                }
                
                // Add "CLICK HERE" text at the bottom
                infoCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                infoCtx.fillRect(0, 412, 512, 100);
                infoCtx.fillStyle = '#ff0000';
                infoCtx.font = 'bold 40px Arial';
                infoCtx.textAlign = 'center';
                infoCtx.fillText('CLICK HERE', 256, 470);
                
                const infoTexture = new THREE.CanvasTexture(infoCanvas);
                const infoPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.5, 0.5),
                    new THREE.MeshStandardMaterial({ map: infoTexture })
                );
                
                // Position based on wall - center of the face that points to center
                let infoX = 0, infoZ = 0;
                if (pos.wall === 'back') {
                    // Face forward toward center
                    infoX = 0;       // Center
                    infoZ = 0.31;    // Front face
                } else if (pos.wall === 'front') {
                    // Face backward toward center
                    infoX = 0;       // Center
                    infoZ = -0.31;   // Back face
                } else if (pos.wall === 'left') {
                    // Face right toward center
                    infoX = 0.31;    // Right face
                    infoZ = 0;       // Center
                } else if (pos.wall === 'right') {
                    // Face left toward center
                    infoX = -0.31;   // Left face
                    infoZ = 0;       // Center
                }
                
                infoPlane.position.set(infoX, 0.5, infoZ); // Middle height position
                infoPlane.rotation.y = rotationY;
                infoPlane.userData = { isInfoFrame: true };
                group.add(infoPlane);

                group.position.set(pos.x, 0, pos.z);
                
                group.userData = { 
                    artwork: {
                        id: pieceData.id,
                        title: pieceData.title,
                        artist: pieceData.artist,
                        year: pieceData.year,
                        description: pieceData.description
                    }
                };
                artworkMeshes.push(group);
                scene.add(group);

                // Enhanced spotlight with warm dramatic glow matching reference
                const spot = new THREE.SpotLight(0xffb870, 2.5);
                spot.position.set(pos.x, 5.5, pos.z);
                spot.target = artPiece;
                spot.angle = Math.PI / 7;
                spot.penumbra = 0.6;
                spot.distance = 10;
                spot.decay = 2;
                if (i < 12) {
                    spot.castShadow = true;
                    spot.shadow.mapSize.width = 512;
                    spot.shadow.mapSize.height = 512;
                }
                scene.add(spot);
                
                // Add wall wash light for that dramatic glow on walls
                const wallWash = new THREE.SpotLight(0xffa860, 1.0);
                wallWash.position.set(pos.x, 4.5, pos.z);
                
                // Point at wall behind the piece
                const wallTarget = new THREE.Object3D();
                if (pos.wall === 'back') {
                    wallTarget.position.set(pos.x, 3, pos.z - 0.5);
                } else if (pos.wall === 'front') {
                    wallTarget.position.set(pos.x, 3, pos.z + 0.5);
                } else if (pos.wall === 'left') {
                    wallTarget.position.set(pos.x - 0.5, 3, pos.z);
                } else if (pos.wall === 'right') {
                    wallTarget.position.set(pos.x + 0.5, 3, pos.z);
                }
                scene.add(wallTarget);
                wallWash.target = wallTarget;
                wallWash.angle = Math.PI / 4;
                wallWash.penumbra = 0.8;
                scene.add(wallWash);
            });

            // Central platform - Elegant stepped display with marble and gold
            // Main platform - white marble
            const platformCanvas = document.createElement('canvas');
            platformCanvas.width = 512;
            platformCanvas.height = 512;
            const platformCtx = platformCanvas.getContext('2d');
            
            // White marble
            platformCtx.fillStyle = '#f0f0ea';
            platformCtx.fillRect(0, 0, 512, 512);
            
            // Marble veining
            for (let i = 0; i < 40; i++) {
                platformCtx.strokeStyle = `rgba(170, 165, 160, ${0.12 + Math.random() * 0.18})`;
                platformCtx.lineWidth = 1 + Math.random() * 2.5;
                platformCtx.beginPath();
                platformCtx.moveTo(Math.random() * 512, Math.random() * 512);
                for (let j = 0; j < 4; j++) {
                    platformCtx.lineTo(Math.random() * 512, Math.random() * 512);
                }
                platformCtx.stroke();
            }
            
            // Texture
            for (let i = 0; i < 4000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const brightness = 225 + Math.random() * 30;
                const alpha = Math.random() * 0.1;
                platformCtx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness-5}, ${alpha})`;
                platformCtx.fillRect(x, y, 1, 1);
            }
            
            const platformTexture = new THREE.CanvasTexture(platformCanvas);
            platformTexture.wrapS = THREE.RepeatWrapping;
            platformTexture.wrapT = THREE.RepeatWrapping;
            platformTexture.repeat.set(3, 3);
            
            // Three-tiered platform
            const platform1 = new THREE.Mesh(
                new THREE.BoxGeometry(9, 0.2, 9, 8, 2, 8),
                new THREE.MeshStandardMaterial({ 
                    map: platformTexture,
                    color: 0xf0f0ea,
                    roughness: 0.3,
                    metalness: 0.1
                })
            );
            platform1.position.set(0, 0.1, 0);
            platform1.castShadow = true;
            platform1.receiveShadow = true;
            scene.add(platform1);
            
            const platform2 = new THREE.Mesh(
                new THREE.BoxGeometry(8, 0.25, 8, 8, 2, 8),
                new THREE.MeshStandardMaterial({ 
                    map: platformTexture,
                    color: 0xf0f0ea,
                    roughness: 0.3,
                    metalness: 0.1
                })
            );
            platform2.position.set(0, 0.325, 0);
            platform2.castShadow = true;
            platform2.receiveShadow = true;
            scene.add(platform2);
            
            const platform3 = new THREE.Mesh(
                new THREE.BoxGeometry(7, 0.3, 7, 8, 2, 8),
                new THREE.MeshStandardMaterial({ 
                    map: platformTexture,
                    color: 0xf0f0ea,
                    roughness: 0.3,
                    metalness: 0.1
                })
            );
            platform3.position.set(0, 0.6, 0);
            platform3.castShadow = true;
            platform3.receiveShadow = true;
            scene.add(platform3);
            
            // Gold trim around each tier
            [9.1, 8.1, 7.1].forEach((size, index) => {
                const trimHeight = [0.2, 0.45, 0.75][index];
                const edgeTrim = new THREE.Mesh(
                    new THREE.BoxGeometry(size, 0.05, size),
                    new THREE.MeshStandardMaterial({
                        color: 0xd4af37,
                        roughness: 0.15,
                        metalness: 0.95,
                        emissive: 0x4a3820,
                        emissiveIntensity: 0.15
                    })
                );
                edgeTrim.position.set(0, trimHeight, 0);
                edgeTrim.castShadow = true;
                scene.add(edgeTrim);
            });

            // Central sculpture - Elegant gold and crystal abstract art
            for (let i = 0; i < 25; i++) {
                const h = 0.6 + Math.random() * 2.2;
                const s = 0.12 + Math.random() * 0.25;
                
                // Vary the shapes - mostly vertical elegant forms
                const shapeType = Math.random();
                let geometry;
                if (shapeType < 0.4) {
                    // Tall elegant cylinders
                    geometry = new THREE.CylinderGeometry(s/2, s/2.5, h, 8);
                } else if (shapeType < 0.7) {
                    // Tapered obelisks
                    geometry = new THREE.ConeGeometry(s/2, h, 6);
                } else {
                    // Crystal-like shapes
                    geometry = new THREE.OctahedronGeometry(s * 0.7);
                }
                
                // Mix of gold and translucent crystal materials
                const materialType = Math.random();
                let material;
                if (materialType < 0.6) {
                    // Brushed gold
                    material = new THREE.MeshStandardMaterial({ 
                        color: 0xd4af37,
                        roughness: 0.25,
                        metalness: 0.9,
                        emissive: 0x4a3820,
                        emissiveIntensity: 0.15
                    });
                } else {
                    // Translucent crystal
                    material = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.05,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.85,
                        emissive: 0xffffee,
                        emissiveIntensity: 0.3
                    });
                }
                
                const sculpture = new THREE.Mesh(geometry, material);
                sculpture.position.set(
                    (Math.random() - 0.5) * 5.5,
                    0.75 + h / 2,
                    (Math.random() - 0.5) * 5.5
                );
                sculpture.rotation.y = Math.random() * Math.PI * 2;
                sculpture.castShadow = true;
                sculpture.receiveShadow = true;
                scene.add(sculpture);
            }

            // CONTROLS
            const keys = {};
            let cameraYaw = 0;
            let cameraPitch = 0;
            let mouseX = window.innerWidth / 2;
            let mouseY = window.innerHeight / 2;
            const edgeThreshold = 100;
            const rotationSpeed = 0.05;
            let isDetailViewOpen = false; // Track if detail panel is open

            // Mobile mode
            let isMobileMode = false;
            const joystickLeft = { active: false, x: 0, y: 0, startX: 0, startY: 0 };
            const joystickRight = { active: false, x: 0, y: 0, startX: 0, startY: 0 };

            document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            // Mobile joystick controls - fixed for multi-touch
            function setupJoystick(elementId, joystickData) {
                const joystick = document.getElementById(elementId);
                const inner = joystick.querySelector('.joystick-inner');
                let touchId = null;

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Get the first touch on this joystick
                    const touch = e.changedTouches[0];
                    touchId = touch.identifier;
                    
                    const rect = joystick.getBoundingClientRect();
                    joystickData.active = true;
                    joystickData.startX = rect.left + rect.width / 2;
                    joystickData.startY = rect.top + rect.height / 2;
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (!joystickData.active || touchId === null) return;
                    
                    // Find the touch that belongs to this joystick
                    let touch = null;
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === touchId) {
                            touch = e.touches[i];
                            break;
                        }
                    }
                    
                    if (!touch) return;
                    
                    const deltaX = touch.clientX - joystickData.startX;
                    const deltaY = touch.clientY - joystickData.startY;
                    
                    const distance = Math.min(35, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                    const angle = Math.atan2(deltaY, deltaX);
                    
                    joystickData.x = Math.cos(angle) * distance / 35;
                    joystickData.y = Math.sin(angle) * distance / 35;
                    
                    inner.style.transform = `translate(calc(-50% + ${joystickData.x * 35}px), calc(-50% + ${joystickData.y * 35}px))`;
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Check if our touch ended
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === touchId) {
                            joystickData.active = false;
                            joystickData.x = 0;
                            joystickData.y = 0;
                            touchId = null;
                            inner.style.transform = 'translate(-50%, -50%)';
                            break;
                        }
                    }
                }, { passive: false });
                
                joystick.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    joystickData.active = false;
                    joystickData.x = 0;
                    joystickData.y = 0;
                    touchId = null;
                    inner.style.transform = 'translate(-50%, -50%)';
                }, { passive: false });
            }

            setupJoystick('joystick-left', joystickLeft);
            setupJoystick('joystick-right', joystickRight);

            // Mode toggle
            document.getElementById('mode-toggle-btn').addEventListener('click', () => {
                isMobileMode = !isMobileMode;
                console.log('Mobile mode:', isMobileMode);
                const mobileControls = document.querySelector('.mobile-controls');
                mobileControls.classList.toggle('active', isMobileMode);
                console.log('Mobile controls active:', mobileControls.classList.contains('active'));
                
                // Move minimap to top-right and resize in mobile mode
                const minimap = document.getElementById('minimap');
                minimap.classList.toggle('mobile-mode', isMobileMode);
                updateMinimapSize();
                
                document.getElementById('mode-toggle-btn').textContent = isMobileMode ? 'Switch to Desktop' : 'Switch to Mobile';
                document.getElementById('desktop-controls').style.display = isMobileMode ? 'none' : 'block';
                document.getElementById('mobile-controls-text').style.display = isMobileMode ? 'block' : 'none';
            });

            // Fullscreen
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            });

            // Minimize controls
            document.getElementById('minimize-btn').addEventListener('click', () => {
                const infoBox = document.getElementById('info');
                const minimizeBtn = document.getElementById('minimize-btn');
                if (infoBox.classList.contains('minimized')) {
                    infoBox.classList.remove('minimized');
                    minimizeBtn.textContent = '−';
                    minimizeBtn.title = 'Minimize';
                } else {
                    infoBox.classList.add('minimized');
                    minimizeBtn.textContent = '+';
                    minimizeBtn.title = 'Expand';
                }
            });

            // Click detection
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
                const intersects = raycaster.intersectObjects(artworkMeshes, true);
                
                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    
                    // Check if the clicked object itself is an info frame
                    if (obj.userData && obj.userData.isInfoFrame) {
                        let artworkGroup = obj.parent;
                        while (artworkGroup && !artworkGroup.userData.artwork) {
                            artworkGroup = artworkGroup.parent;
                        }
                        if (artworkGroup && artworkGroup.userData.artwork) {
                            const art = artworkGroup.userData.artwork;
                            
                            document.getElementById('detail-title').textContent = art.title;
                            document.getElementById('detail-artist').textContent = 'Artist: ' + art.artist;
                            document.getElementById('detail-year').textContent = 'Year: ' + art.year;
                            document.getElementById('detail-description').textContent = art.description;
                            
                            const detailImage = document.getElementById('detail-image');
                            if (loadedImages[art.id]) {
                                detailImage.src = loadedImages[art.id].src;
                                detailImage.style.display = 'block';
                            } else {
                                detailImage.style.display = 'none';
                            }
                            
                            document.getElementById('artwork-detail').classList.add('active');
                            isDetailViewOpen = true; // Disable camera movement
                        }
                        return;
                    }
                    
                    // Check parent hierarchy for info frame
                    let parent = obj.parent;
                    while (parent) {
                        if (parent.userData && parent.userData.isInfoFrame) {
                            let artworkGroup = parent.parent;
                            while (artworkGroup && !artworkGroup.userData.artwork) {
                                artworkGroup = artworkGroup.parent;
                            }
                            if (artworkGroup && artworkGroup.userData.artwork) {
                                const art = artworkGroup.userData.artwork;
                                
                                document.getElementById('detail-title').textContent = art.title;
                                document.getElementById('detail-artist').textContent = 'Artist: ' + art.artist;
                                document.getElementById('detail-year').textContent = 'Year: ' + art.year;
                                document.getElementById('detail-description').textContent = art.description;
                                
                                const detailImage = document.getElementById('detail-image');
                                if (loadedImages[art.id]) {
                                    detailImage.src = loadedImages[art.id].src;
                                    detailImage.style.display = 'block';
                                } else {
                                    detailImage.style.display = 'none';
                                }
                                
                                document.getElementById('artwork-detail').classList.add('active');
                                isDetailViewOpen = true; // Disable camera movement
                            }
                            return;
                        }
                        parent = parent.parent;
                    }
                }
            });

            document.getElementById('close-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                document.getElementById('artwork-detail').classList.remove('active');
                isDetailViewOpen = false; // Re-enable camera movement
            });

            // Image enlargement
            document.getElementById('detail-image').addEventListener('click', (e) => {
                e.stopPropagation();
                const src = e.target.src;
                document.getElementById('enlarged-image').src = src;
                document.getElementById('image-overlay').classList.add('active');
            });

            document.getElementById('image-overlay').addEventListener('click', () => {
                document.getElementById('image-overlay').classList.remove('active');
            });

            // MINIMAP
            const minimapCanvas = document.getElementById('minimap');
            const minimapCtx = minimapCanvas.getContext('2d');
            
            function updateMinimapSize() {
                const size = isMobileMode ? 80 : 100;
                minimapCanvas.width = size;
                minimapCanvas.height = size;
            }
            
            updateMinimapSize();

            function drawMinimap() {
                const size = isMobileMode ? 80 : 100;
                const padding = size * 0.1;
                const mapSize = size - (padding * 2);
                
                minimapCtx.clearRect(0, 0, size, size);
                
                // Draw room outline
                minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                minimapCtx.lineWidth = 2;
                minimapCtx.strokeRect(padding, padding, mapSize, mapSize);
                
                // Draw center platform
                minimapCtx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                const centerSize = mapSize * 8 / 40;
                const center = size / 2;
                minimapCtx.fillRect(center - centerSize/2, center - centerSize/2, centerSize, centerSize);
                
                // Draw artworks
                positions.forEach(pos => {
                    const mapX = center + (pos.x / 40) * mapSize;
                    const mapZ = center + (pos.z / 40) * mapSize;
                    
                    minimapCtx.fillStyle = 'rgba(255, 200, 100, 0.8)';
                    minimapCtx.beginPath();
                    minimapCtx.arc(mapX, mapZ, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                });
                
                // Draw player position
                const playerX = center + (camera.position.x / 40) * mapSize;
                const playerZ = center + (camera.position.z / 40) * mapSize;
                
                minimapCtx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                minimapCtx.beginPath();
                minimapCtx.arc(playerX, playerZ, 3, 0, Math.PI * 2);
                minimapCtx.fill();
                
                // Draw player direction
                minimapCtx.strokeStyle = 'rgba(255, 50, 50, 0.9)';
                minimapCtx.lineWidth = 2;
                minimapCtx.beginPath();
                minimapCtx.moveTo(playerX, playerZ);
                minimapCtx.lineTo(
                    playerX + Math.sin(cameraYaw) * 8,
                    playerZ + Math.cos(cameraYaw) * 8
                );
                minimapCtx.stroke();
            }

            // ANIMATION LOOP
            function animate() {
                requestAnimationFrame(animate);

                // Desktop controls - mouse edge rotation (only if detail view is closed)
                if (!isMobileMode && !isDetailViewOpen) {
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;

                    if (mouseX < edgeThreshold) {
                        cameraYaw += rotationSpeed;
                    }
                    if (mouseX > screenWidth - edgeThreshold) {
                        cameraYaw -= rotationSpeed;
                    }
                    if (mouseY < edgeThreshold) {
                        cameraPitch += rotationSpeed * 0.5;
                    }
                    if (mouseY > screenHeight - edgeThreshold) {
                        cameraPitch -= rotationSpeed * 0.5;
                    }
                }

                // Mobile controls - joystick rotation (only if detail view is closed)
                if (isMobileMode && !isDetailViewOpen && joystickRight.active) {
                    cameraYaw -= joystickRight.x * 0.1;
                    cameraPitch -= joystickRight.y * 0.05;
                }

                cameraPitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, cameraPitch));

                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraYaw;
                camera.rotation.x = cameraPitch;

                // Movement
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

                const moveSpeed = 0.15;

                // Desktop movement (only if detail view is closed)
                if (!isMobileMode && !isDetailViewOpen) {
                    if (keys['w'] || keys['arrowup']) camera.position.addScaledVector(forward, moveSpeed);
                    if (keys['s'] || keys['arrowdown']) camera.position.addScaledVector(forward, -moveSpeed);
                    if (keys['a'] || keys['arrowleft']) camera.position.addScaledVector(right, -moveSpeed);
                    if (keys['d'] || keys['arrowright']) camera.position.addScaledVector(right, moveSpeed);
                }

                // Mobile movement (only if detail view is closed)
                if (isMobileMode && !isDetailViewOpen && joystickLeft.active) {
                    camera.position.addScaledVector(forward, -joystickLeft.y * moveSpeed);
                    camera.position.addScaledVector(right, joystickLeft.x * moveSpeed);
                }

                // Boundary limits
                camera.position.x = Math.max(-18, Math.min(18, camera.position.x));
                camera.position.z = Math.max(-18, Math.min(18, camera.position.z));

                drawMinimap();
                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Start loading when page loads
        init();
    </script>
</body>
</html>
