<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Art Gallery</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; overflow: hidden; background: #000; cursor: default; touch-action: none; }
        #canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            flex-direction: column;
            color: white;
        }
        
        #loading-screen.hidden { display: none; }
        
        .loader {
            border: 8px solid #333;
            border-top: 8px solid #4CAF50;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #loading-text {
            font-size: 18px;
            margin-top: 10px;
        }
        
        #info {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 10px;
            font-size: 14px; max-width: 300px; z-index: 10;
            transition: all 0.3s ease;
        }
        #info.minimized {
            padding: 8px;
            max-width: 120px;
        }
        #info.minimized .info-content { display: none; }
        #info h3 { margin-bottom: 8px; }
        
        #minimize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            line-height: 20px;
            padding: 0;
        }
        #minimize-btn:hover { background: rgba(255, 255, 255, 0.3); }
        
        #artwork-detail {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: white; padding: 20px; border-radius: 15px;
            max-width: 90vw; 
            max-height: 90vh;
            width: auto;
            height: auto;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            transition: transform 0.3s ease; z-index: 100;
            -webkit-overflow-scrolling: touch;
        }
        #artwork-detail.active { transform: translate(-50%, -50%) scale(1); }
        #artwork-detail h2 { margin-bottom: 10px; color: #333; font-size: clamp(18px, 3vw, 24px); }
        #artwork-detail p { margin-bottom: 8px; color: #666; font-size: clamp(12px, 2vw, 16px); }
        #artwork-detail img { 
            max-width: 100%; 
            max-height: 60vh;
            width: auto;
            height: auto;
            object-fit: contain;
            margin: 15px 0; 
            border-radius: 8px;
            cursor: pointer;
        }
        #close-btn {
            position: absolute; top: 15px; right: 15px;
            background: #e74c3c; color: white; border: none;
            width: 30px; height: 30px; border-radius: 50%;
            cursor: pointer; font-size: 18px; line-height: 30px;
            z-index: 101;
        }
        #close-btn:hover { background: #c0392b; }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        #minimap.mobile-mode {
            bottom: auto;
            top: 20px;
            left: auto;
            right: 20px;
            transform: none;
            width: 80px;
            height: 80px;
        }

        .mobile-controls {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 99;
        }
        .mobile-controls.active { 
            display: block;
        }
        
        .joystick {
            position: fixed;
            width: 120px;
            height: 120px;
            background: rgba(100, 150, 255, 0.4);
            border: 4px solid rgba(100, 150, 255, 0.8);
            border-radius: 50%;
            pointer-events: all;
            z-index: 100;
        }
        #joystick-left { bottom: 40px; left: 40px; }
        #joystick-right { bottom: 40px; right: 40px; }
        
        .joystick-inner {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid rgba(100, 150, 255, 1);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .control-btn:hover { background: rgba(0, 0, 0, 0.9); }

        #image-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        #image-overlay.active { display: flex; }
        #image-overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loader"></div>
        <div id="loading-text">Loading gallery...</div>
    </div>

    <canvas id="canvas"></canvas>
    
    <div id="info">
        <button id="minimize-btn" title="Minimize">−</button>
        <div class="info-content">
            <h3>Controls</h3>
            <p id="desktop-controls"><strong>WASD/Arrows</strong> - Move<br><strong>Mouse Edges</strong> - Look<br><strong>Click Frame</strong> - Info</p>
            <p id="mobile-controls-text" style="display:none;"><strong>Left Stick</strong> - Move<br><strong>Right Stick</strong> - Look<br><strong>Tap Frame</strong> - Info</p>
            <button id="mode-toggle-btn" class="control-btn" style="margin-top: 10px; width: 100%;">Switch to Mobile</button>
            <button id="fullscreen-btn" class="control-btn" style="margin-top: 5px; width: 100%;">Fullscreen</button>
        </div>
    </div>
    
    <canvas id="minimap"></canvas>
    
    <div class="mobile-controls">
        <div id="joystick-left" class="joystick">
            <div class="joystick-inner"></div>
        </div>
        <div id="joystick-right" class="joystick">
            <div class="joystick-inner"></div>
        </div>
    </div>
    
    <div id="artwork-detail">
        <button id="close-btn">×</button>
        <h2 id="detail-title"></h2>
        <p id="detail-artist"></p>
        <p id="detail-year"></p>
        <img id="detail-image" src="" alt="" style="display: none;">
        <p id="detail-description"></p>
    </div>

    <div id="image-overlay">
        <img id="enlarged-image" src="" alt="">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // Configuration
        const CONFIG = {
            descriptionsFile: './descriptions.xlsx',
            imagesFolder: './images/',
            imageExtensions: ['jpg', 'jpeg', 'png', 'JPG', 'JPEG', 'PNG']
        };

        let galleryData = {
            pieces: []
        };

        // Load Excel file with descriptions
        async function loadDescriptions() {
            try {
                const response = await fetch(CONFIG.descriptionsFile);
                const arrayBuffer = await response.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const data = XLSX.utils.sheet_to_json(firstSheet, { defval: '' });
                
                console.log('Excel data loaded:', data);
                
                if (data.length === 0) {
                    throw new Error('Excel file is empty');
                }
                
                data.forEach(row => {
                    const piece = {
                        id: row['ID'] || row['id'] || row['Piece'] || row['piece'] || row['Number'] || row['number'] || row['#'],
                        title: row['Title'] || row['title'] || row['Name'] || row['name'] || 'Untitled',
                        artist: row['Artist'] || row['artist'] || row['Creator'] || row['creator'] || 'Unknown Artist',
                        year: String(row['Year'] || row['year'] || row['Date'] || row['date'] || ''),
                        description: row['Description'] || row['description'] || row['Details'] || row['details'] || '',
                        has3DModel: true
                    };
                    
                    if (piece.id) {
                        galleryData.pieces.push(piece);
                    }
                });
                
                galleryData.pieces.sort((a, b) => a.id - b.id);
                
                console.log(`✓ Loaded ${galleryData.pieces.length} piece descriptions from Excel`);
                return true;
            } catch (error) {
                console.error('Error loading descriptions:', error);
                console.log('Using default placeholder descriptions instead');
                for (let i = 1; i <= 20; i++) {
                    galleryData.pieces.push({
                        id: i,
                        title: `Art Piece ${i}`,
                        artist: 'Artist Name',
                        year: '2024',
                        description: `Description for art piece ${i}. Upload descriptions.xlsx with columns: ID, Title, Artist, Year, Description`,
                        has3DModel: true
                    });
                }
                return false;
            }
        }

        // Preload all images
        const loadedImages = {};
        async function preloadImages() {
            const imagePromises = [];
            
            for (let piece of galleryData.pieces) {
                const promise = new Promise((resolve) => {
                    let extIndex = 0;
                    
                    function tryNextExtension() {
                        if (extIndex >= CONFIG.imageExtensions.length) {
                            console.log(`⚠ Image not found for piece ${piece.id}`);
                            resolve();
                            return;
                        }
                        
                        const ext = CONFIG.imageExtensions[extIndex];
                        const img = new Image();
                        
                        img.onload = function() {
                            loadedImages[piece.id] = img;
                            console.log(`✓ Loaded image for piece ${piece.id}`);
                            resolve();
                        };
                        
                        img.onerror = function() {
                            extIndex++;
                            tryNextExtension();
                        };
                        
                        img.src = `${CONFIG.imagesFolder}piece${piece.id}.${ext}`;
                    }
                    
                    tryNextExtension();
                });
                
                imagePromises.push(promise);
            }
            
            await Promise.all(imagePromises);
            console.log(`✓ Preloaded ${Object.keys(loadedImages).length} images`);
        }

        // Initialize gallery
        async function init() {
            document.getElementById('loading-text').textContent = 'Loading descriptions...';
            await loadDescriptions();
            
            document.getElementById('loading-text').textContent = 'Loading images...';
            await preloadImages();
            
            document.getElementById('loading-text').textContent = 'Building gallery...';
            await new Promise(resolve => setTimeout(resolve, 500));
            
            document.getElementById('loading-screen').classList.add('hidden');
            initGallery();
        }

        function initGallery() {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1612);
            scene.fog = new THREE.Fog(0x1a1612, 25, 60);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 10);

            const canvas = document.getElementById('canvas');
            const renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: false, // OPTIMIZATION: Disable antialiasing
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap; // OPTIMIZATION: Use basic shadow map instead of PCF

            // OPTIMIZED LIGHTING - Fewer lights, simpler shadows
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Main overhead light - single light instead of multiple
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);
            mainLight.position.set(0, 10, 0);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024; // OPTIMIZATION: Reduced from default
            mainLight.shadow.mapSize.height = 1024;
            mainLight.shadow.camera.left = -25;
            mainLight.shadow.camera.right = 25;
            mainLight.shadow.camera.top = 25;
            mainLight.shadow.camera.bottom = -25;
            scene.add(mainLight);

            // Accent lights for ambiance (no shadows)
            const accentLight1 = new THREE.PointLight(0xffd700, 0.3, 30);
            accentLight1.position.set(-10, 4, -10);
            scene.add(accentLight1);

            const accentLight2 = new THREE.PointLight(0xffd700, 0.3, 30);
            accentLight2.position.set(10, 4, 10);
            scene.add(accentLight2);

            // OPTIMIZED FLOOR - Simple solid color
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(40, 40),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2a1e19,
                    roughness: 0.85,
                    metalness: 0.05
                })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // OPTIMIZED CEILING - Simple geometry, no shadows
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(40, 40),
                new THREE.MeshBasicMaterial({ color: 0x0a0a0a })
            );
            ceiling.position.y = 6;
            ceiling.rotation.x = Math.PI / 2;
            scene.add(ceiling);

            // Simple chandelier decoration (no complex geometry)
            const chandelier = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 16, 16),
                new THREE.MeshStandardMaterial({
                    color: 0xd4af37,
                    roughness: 0.2,
                    metalness: 0.9,
                    emissive: 0x4a3820,
                    emissiveIntensity: 0.3
                })
            );
            chandelier.position.set(0, 5, 0);
            scene.add(chandelier);

            // OPTIMIZED WALLS - Simpler material
            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0x3d2228,
                roughness: 0.92,
                metalness: 0.02
            });

            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 6), wallMat);
            backWall.position.set(0, 3, -20);
            backWall.receiveShadow = true;
            scene.add(backWall);

            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 6), wallMat);
            leftWall.position.set(-20, 3, 0);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 6), wallMat);
            rightWall.position.set(20, 3, 0);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 6), wallMat);
            frontWall.position.set(0, 3, 20);
            frontWall.rotation.y = Math.PI;
            frontWall.receiveShadow = true;
            scene.add(frontWall);

            const artworkMeshes = [];

            // OPTIMIZED PEDESTAL MATERIAL - Simple, no procedural texture
            const pedestalMat = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f0,
                roughness: 0.25,
                metalness: 0.1
            });

            const artMat1 = new THREE.MeshStandardMaterial({ color: 0x3a5f7a, roughness: 0.7 });
            const artMat2 = new THREE.MeshStandardMaterial({ color: 0xb08560, roughness: 0.7 });
            const artMat3 = new THREE.MeshStandardMaterial({ color: 0x5a4d42, roughness: 0.7 });
            const artMaterials = [artMat1, artMat2, artMat3];

            // OPTIMIZED GEOMETRY - Simple boxes
            const pedestalGeo = new THREE.BoxGeometry(1.2, 1, 0.6);
            const artGeo = new THREE.BoxGeometry(0.6, 0.6, 0.15);

            // Distribute pieces across walls
            const totalPieces = galleryData.pieces.length;
            const positions = [];
            
            const piecesPerWall = 5;
            let backWallCount = Math.min(piecesPerWall, totalPieces);
            let rightWallCount = Math.min(piecesPerWall, Math.max(0, totalPieces - backWallCount));
            let frontWallCount = Math.min(piecesPerWall, Math.max(0, totalPieces - backWallCount - rightWallCount));
            let leftWallCount = Math.max(0, totalPieces - backWallCount - rightWallCount - frontWallCount);
            
            // Back wall
            for (let i = 0; i < backWallCount; i++) {
                const spacing = 40 / (backWallCount + 1);
                positions.push({ x: -20 + spacing * (i + 1), z: -19, wall: 'back' });
            }
            
            // Right wall
            for (let i = 0; i < rightWallCount; i++) {
                const spacing = 40 / (rightWallCount + 1);
                positions.push({ x: 19, z: -20 + spacing * (i + 1), wall: 'right' });
            }
            
            // Front wall
            for (let i = 0; i < frontWallCount; i++) {
                const spacing = 40 / (frontWallCount + 1);
                positions.push({ x: 20 - spacing * (i + 1), z: 19, wall: 'front' });
            }
            
            // Left wall
            for (let i = 0; i < leftWallCount; i++) {
                const spacing = 40 / (leftWallCount + 1);
                positions.push({ x: -19, z: 20 - spacing * (i + 1), wall: 'left' });
            }

            positions.forEach((pos, i) => {
                if (i >= galleryData.pieces.length) return;
                
                const pieceData = galleryData.pieces[i];
                const group = new THREE.Group();
                
                // Determine rotation
                let rotationY = 0;
                if (pos.wall === 'back') {
                    rotationY = 0;
                } else if (pos.wall === 'front') {
                    rotationY = Math.PI;
                } else if (pos.wall === 'left') {
                    rotationY = Math.PI / 2;
                } else if (pos.wall === 'right') {
                    rotationY = -Math.PI / 2;
                }
                
                // OPTIMIZED PEDESTAL - Simple box, only pedestal casts shadows
                const pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
                pedestal.position.y = 0.5;
                pedestal.rotation.y = rotationY;
                pedestal.castShadow = true;
                pedestal.receiveShadow = true;
                group.add(pedestal);
                
                // Gold trim
                const goldTrim = new THREE.Mesh(
                    new THREE.BoxGeometry(1.25, 0.08, 0.65),
                    new THREE.MeshStandardMaterial({
                        color: 0xd4af37,
                        roughness: 0.15,
                        metalness: 0.95,
                        emissive: 0x4a3820,
                        emissiveIntensity: 0.1
                    })
                );
                goldTrim.position.y = 0.04;
                goldTrim.rotation.y = rotationY;
                group.add(goldTrim);

                // OPTIMIZED NUMBER TEXT - Simpler canvas
                const numberCanvas = document.createElement('canvas');
                numberCanvas.width = 128; // OPTIMIZATION: Reduced from 256
                numberCanvas.height = 128;
                const numberCtx = numberCanvas.getContext('2d');
                numberCtx.fillStyle = '#FFD700';
                numberCtx.font = 'bold 60px Arial';
                numberCtx.textAlign = 'center';
                numberCtx.textBaseline = 'middle';
                numberCtx.fillText(pieceData.id.toString(), 64, 64);
                
                const numberTexture = new THREE.CanvasTexture(numberCanvas);
                const numberPlate = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 0.3),
                    new THREE.MeshStandardMaterial({ 
                        map: numberTexture,
                        transparent: true
                    })
                );
                
                let numberX = 0, numberZ = 0;
                if (pos.wall === 'back') {
                    numberX = -0.4;
                    numberZ = 0.31;
                } else if (pos.wall === 'front') {
                    numberX = 0.4;
                    numberZ = -0.31;
                } else if (pos.wall === 'left') {
                    numberX = 0.31;
                    numberZ = -0.4;
                } else if (pos.wall === 'right') {
                    numberX = -0.31;
                    numberZ = 0.4;
                }
                
                numberPlate.position.set(numberX, 0.7, numberZ);
                numberPlate.rotation.y = rotationY;
                group.add(numberPlate);

                // Art piece - circular disc
                let artPiece;
                if (pieceData.has3DModel) {
                    if (loadedImages[pieceData.id]) {
                        // OPTIMIZED: Reduced segments from 64 to 32
                        const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.02, 32);
                        const discTexture = new THREE.Texture(loadedImages[pieceData.id]);
                        discTexture.needsUpdate = true;
                        
                        const materials = [
                            new THREE.MeshStandardMaterial({ color: 0x8B7355 }),
                            new THREE.MeshStandardMaterial({ map: discTexture }),
                            new THREE.MeshStandardMaterial({ map: discTexture })
                        ];
                        
                        const art = new THREE.Mesh(cylinderGeometry, materials);
                        art.position.y = 1.5;
                        art.rotation.z = Math.PI / 2;
                        art.rotation.y = rotationY + Math.PI / 2;
                        art.castShadow = false; // OPTIMIZATION: Art pieces don't cast shadows
                        group.add(art);
                        artPiece = art;
                    } else {
                        const art = new THREE.Mesh(artGeo, artMaterials[i % 3]);
                        art.position.y = 1.2;
                        art.rotation.y = rotationY;
                        art.castShadow = false;
                        group.add(art);
                        artPiece = art;
                    }
                } else {
                    const invisibleBox = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.6, 0.15),
                        new THREE.MeshBasicMaterial({ visible: false })
                    );
                    invisibleBox.position.y = 1.2;
                    invisibleBox.rotation.y = rotationY;
                    group.add(invisibleBox);
                    artPiece = invisibleBox;
                }

                // OPTIMIZED INFO PANEL - Smaller canvas
                const infoCanvas = document.createElement('canvas');
                infoCanvas.width = 256; // OPTIMIZATION: Reduced from 512
                infoCanvas.height = 256;
                const infoCtx = infoCanvas.getContext('2d');
                
                if (loadedImages[pieceData.id]) {
                    infoCtx.drawImage(loadedImages[pieceData.id], 0, 0, 256, 256);
                } else {
                    infoCtx.fillStyle = '#ffffff';
                    infoCtx.fillRect(0, 0, 256, 256);
                    infoCtx.fillStyle = '#999999';
                    infoCtx.font = '16px Arial';
                    infoCtx.textAlign = 'center';
                    infoCtx.fillText('No Image', 128, 110);
                    infoCtx.font = '12px Arial';
                    infoCtx.fillText(`Piece ${pieceData.id}`, 128, 140);
                }
                
                infoCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                infoCtx.fillRect(0, 206, 256, 50);
                infoCtx.fillStyle = '#ff0000';
                infoCtx.font = 'bold 20px Arial';
                infoCtx.textAlign = 'center';
                infoCtx.fillText('CLICK HERE', 128, 235);
                
                const infoTexture = new THREE.CanvasTexture(infoCanvas);
                const infoPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.5, 0.5),
                    new THREE.MeshStandardMaterial({ map: infoTexture })
                );
                
                let infoX = 0, infoZ = 0;
                if (pos.wall === 'back') {
                    infoX = 0;
                    infoZ = 0.31;
                } else if (pos.wall === 'front') {
                    infoX = 0;
                    infoZ = -0.31;
                } else if (pos.wall === 'left') {
                    infoX = 0.31;
                    infoZ = 0;
                } else if (pos.wall === 'right') {
                    infoX = -0.31;
                    infoZ = 0;
                }
                
                infoPlane.position.set(infoX, 0.4, infoZ);
                infoPlane.rotation.y = rotationY;
                infoPlane.userData.isInfoFrame = true;
                group.add(infoPlane);

                group.position.set(pos.x, 0, pos.z);
                group.userData.artwork = pieceData;
                scene.add(group);
                artworkMeshes.push(infoPlane);
            });

            // OPTIMIZED CENTRAL PLATFORM - Simpler geometry
            const platformMat = new THREE.MeshStandardMaterial({ 
                color: 0xf0f0ea,
                roughness: 0.3,
                metalness: 0.1
            });
            
            const platform1 = new THREE.Mesh(
                new THREE.BoxGeometry(9, 0.2, 9),
                platformMat
            );
            platform1.position.set(0, 0.1, 0);
            platform1.castShadow = true;
            platform1.receiveShadow = true;
            scene.add(platform1);
            
            const platform2 = new THREE.Mesh(
                new THREE.BoxGeometry(8, 0.25, 8),
                platformMat
            );
            platform2.position.set(0, 0.325, 0);
            platform2.castShadow = true;
            platform2.receiveShadow = true;
            scene.add(platform2);
            
            const platform3 = new THREE.Mesh(
                new THREE.BoxGeometry(7, 0.3, 7),
                platformMat
            );
            platform3.position.set(0, 0.6, 0);
            platform3.castShadow = true;
            platform3.receiveShadow = true;
            scene.add(platform3);
            
            // Gold trim
            [9.1, 8.1, 7.1].forEach((size, index) => {
                const trimHeight = [0.2, 0.45, 0.75][index];
                const edgeTrim = new THREE.Mesh(
                    new THREE.BoxGeometry(size, 0.05, size),
                    new THREE.MeshStandardMaterial({
                        color: 0xd4af37,
                        roughness: 0.15,
                        metalness: 0.95,
                        emissive: 0x4a3820,
                        emissiveIntensity: 0.15
                    })
                );
                edgeTrim.position.set(0, trimHeight, 0);
                scene.add(edgeTrim);
            });

            // OPTIMIZED SCULPTURE - Fewer pieces, simpler geometry, no shadows
            for (let i = 0; i < 15; i++) { // OPTIMIZATION: Reduced from 25 to 15
                const h = 0.6 + Math.random() * 2.2;
                const s = 0.12 + Math.random() * 0.25;
                
                const shapeType = Math.random();
                let geometry;
                if (shapeType < 0.4) {
                    geometry = new THREE.CylinderGeometry(s/2, s/2.5, h, 6); // OPTIMIZATION: Reduced segments
                } else if (shapeType < 0.7) {
                    geometry = new THREE.ConeGeometry(s/2, h, 6);
                } else {
                    geometry = new THREE.OctahedronGeometry(s * 0.7);
                }
                
                const materialType = Math.random();
                let material;
                if (materialType < 0.6) {
                    material = new THREE.MeshStandardMaterial({ 
                        color: 0xd4af37,
                        roughness: 0.25,
                        metalness: 0.9,
                        emissive: 0x4a3820,
                        emissiveIntensity: 0.15
                    });
                } else {
                    material = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.05,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.85,
                        emissive: 0xffffee,
                        emissiveIntensity: 0.3
                    });
                }
                
                const sculpture = new THREE.Mesh(geometry, material);
                sculpture.position.set(
                    (Math.random() - 0.5) * 5.5,
                    0.75 + h / 2,
                    (Math.random() - 0.5) * 5.5
                );
                sculpture.rotation.y = Math.random() * Math.PI * 2;
                sculpture.castShadow = false; // OPTIMIZATION: Sculptures don't cast shadows
                sculpture.receiveShadow = false;
                scene.add(sculpture);
            }

            // CONTROLS
            const keys = {};
            let cameraYaw = 0;
            let cameraPitch = 0;

            // FIXED: Add keyboard event listeners for WASD
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Mouse position tracking
            let mouseX = window.innerWidth / 2;
            let mouseY = window.innerHeight / 2;
            const edgeThreshold = 100;
            const rotationSpeed = 0.02;

            window.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            // Mobile controls
            let isMobileMode = false;
            let isDetailViewOpen = false;

            const joystickLeft = { active: false, x: 0, y: 0 };
            const joystickRight = { active: false, x: 0, y: 0 };

            function setupJoystick(elementId, joystickObj) {
                const joystick = document.getElementById(elementId);
                const inner = joystick.querySelector('.joystick-inner');
                
                function handleStart(e) {
                    e.preventDefault();
                    joystickObj.active = true;
                }
                
                function handleMove(e) {
                    if (!joystickObj.active) return;
                    e.preventDefault();
                    
                    const touch = e.touches ? e.touches[0] : e;
                    const rect = joystick.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let deltaX = touch.clientX - centerX;
                    let deltaY = touch.clientY - centerY;
                    
                    const maxDistance = 35;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance > maxDistance) {
                        deltaX = (deltaX / distance) * maxDistance;
                        deltaY = (deltaY / distance) * maxDistance;
                    }
                    
                    joystickObj.x = deltaX / maxDistance;
                    joystickObj.y = deltaY / maxDistance;
                    
                    inner.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                }
                
                function handleEnd(e) {
                    e.preventDefault();
                    joystickObj.active = false;
                    joystickObj.x = 0;
                    joystickObj.y = 0;
                    inner.style.transform = 'translate(-50%, -50%)';
                }
                
                joystick.addEventListener('touchstart', handleStart);
                joystick.addEventListener('mousedown', handleStart);
                document.addEventListener('touchmove', handleMove);
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('touchend', handleEnd);
                document.addEventListener('mouseup', handleEnd);
            }

            setupJoystick('joystick-left', joystickLeft);
            setupJoystick('joystick-right', joystickRight);

            // Mode toggle
            document.getElementById('mode-toggle-btn').addEventListener('click', () => {
                isMobileMode = !isMobileMode;
                const btn = document.getElementById('mode-toggle-btn');
                const mobileControls = document.querySelector('.mobile-controls');
                const minimap = document.getElementById('minimap');
                const desktopControlsText = document.getElementById('desktop-controls');
                const mobileControlsText = document.getElementById('mobile-controls-text');
                
                if (isMobileMode) {
                    btn.textContent = 'Switch to Desktop';
                    mobileControls.classList.add('active');
                    minimap.classList.add('mobile-mode');
                    desktopControlsText.style.display = 'none';
                    mobileControlsText.style.display = 'block';
                } else {
                    btn.textContent = 'Switch to Mobile';
                    mobileControls.classList.remove('active');
                    minimap.classList.remove('mobile-mode');
                    desktopControlsText.style.display = 'block';
                    mobileControlsText.style.display = 'none';
                }
                
                updateMinimapSize();
            });

            // Fullscreen
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            });

            // Minimize info panel
            document.getElementById('minimize-btn').addEventListener('click', () => {
                document.getElementById('info').classList.toggle('minimized');
            });

            // Raycasting for clicks
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            canvas.addEventListener('click', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children, true);

                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    
                    if (obj.userData && obj.userData.isInfoFrame) {
                        let artworkGroup = obj.parent;
                        while (artworkGroup && !artworkGroup.userData.artwork) {
                            artworkGroup = artworkGroup.parent;
                        }
                        if (artworkGroup && artworkGroup.userData.artwork) {
                            const art = artworkGroup.userData.artwork;
                            
                            document.getElementById('detail-title').textContent = art.title;
                            document.getElementById('detail-artist').textContent = 'Artist: ' + art.artist;
                            document.getElementById('detail-year').textContent = 'Year: ' + art.year;
                            document.getElementById('detail-description').textContent = art.description;
                            
                            const detailImage = document.getElementById('detail-image');
                            if (loadedImages[art.id]) {
                                detailImage.src = loadedImages[art.id].src;
                                detailImage.style.display = 'block';
                            } else {
                                detailImage.style.display = 'none';
                            }
                            
                            document.getElementById('artwork-detail').classList.add('active');
                            isDetailViewOpen = true;
                        }
                        return;
                    }
                    
                    let parent = obj.parent;
                    while (parent) {
                        if (parent.userData && parent.userData.isInfoFrame) {
                            let artworkGroup = parent.parent;
                            while (artworkGroup && !artworkGroup.userData.artwork) {
                                artworkGroup = artworkGroup.parent;
                            }
                            if (artworkGroup && artworkGroup.userData.artwork) {
                                const art = artworkGroup.userData.artwork;
                                
                                document.getElementById('detail-title').textContent = art.title;
                                document.getElementById('detail-artist').textContent = 'Artist: ' + art.artist;
                                document.getElementById('detail-year').textContent = 'Year: ' + art.year;
                                document.getElementById('detail-description').textContent = art.description;
                                
                                const detailImage = document.getElementById('detail-image');
                                if (loadedImages[art.id]) {
                                    detailImage.src = loadedImages[art.id].src;
                                    detailImage.style.display = 'block';
                                } else {
                                    detailImage.style.display = 'none';
                                }
                                
                                document.getElementById('artwork-detail').classList.add('active');
                                isDetailViewOpen = true;
                            }
                            return;
                        }
                        parent = parent.parent;
                    }
                }
            });

            document.getElementById('close-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                document.getElementById('artwork-detail').classList.remove('active');
                isDetailViewOpen = false;
            });

            document.getElementById('detail-image').addEventListener('click', (e) => {
                e.stopPropagation();
                const src = e.target.src;
                document.getElementById('enlarged-image').src = src;
                document.getElementById('image-overlay').classList.add('active');
            });

            document.getElementById('image-overlay').addEventListener('click', () => {
                document.getElementById('image-overlay').classList.remove('active');
            });

            // MINIMAP
            const minimapCanvas = document.getElementById('minimap');
            const minimapCtx = minimapCanvas.getContext('2d');
            
            function updateMinimapSize() {
                const size = isMobileMode ? 80 : 100;
                minimapCanvas.width = size;
                minimapCanvas.height = size;
            }
            
            updateMinimapSize();

            function drawMinimap() {
                const size = isMobileMode ? 80 : 100;
                const padding = size * 0.1;
                const mapSize = size - (padding * 2);
                
                minimapCtx.clearRect(0, 0, size, size);
                
                minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                minimapCtx.lineWidth = 2;
                minimapCtx.strokeRect(padding, padding, mapSize, mapSize);
                
                minimapCtx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                const centerSize = mapSize * 8 / 40;
                const center = size / 2;
                minimapCtx.fillRect(center - centerSize/2, center - centerSize/2, centerSize, centerSize);
                
                positions.forEach(pos => {
                    const mapX = center + (pos.x / 40) * mapSize;
                    const mapZ = center + (pos.z / 40) * mapSize;
                    
                    minimapCtx.fillStyle = 'rgba(255, 200, 100, 0.8)';
                    minimapCtx.beginPath();
                    minimapCtx.arc(mapX, mapZ, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                });
                
                const playerX = center + (camera.position.x / 40) * mapSize;
                const playerZ = center + (camera.position.z / 40) * mapSize;
                
                minimapCtx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                minimapCtx.beginPath();
                minimapCtx.arc(playerX, playerZ, 3, 0, Math.PI * 2);
                minimapCtx.fill();
                
                minimapCtx.strokeStyle = 'rgba(255, 50, 50, 0.9)';
                minimapCtx.lineWidth = 2;
                minimapCtx.beginPath();
                minimapCtx.moveTo(playerX, playerZ);
                minimapCtx.lineTo(
                    playerX + Math.sin(cameraYaw) * 8,
                    playerZ + Math.cos(cameraYaw) * 8
                );
                minimapCtx.stroke();
            }

            // ANIMATION LOOP
            function animate() {
                requestAnimationFrame(animate);

                if (!isMobileMode && !isDetailViewOpen) {
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;

                    if (mouseX < edgeThreshold) {
                        cameraYaw += rotationSpeed;
                    }
                    if (mouseX > screenWidth - edgeThreshold) {
                        cameraYaw -= rotationSpeed;
                    }
                    if (mouseY < edgeThreshold) {
                        cameraPitch += rotationSpeed * 0.5;
                    }
                    if (mouseY > screenHeight - edgeThreshold) {
                        cameraPitch -= rotationSpeed * 0.5;
                    }
                }

                if (isMobileMode && !isDetailViewOpen && joystickRight.active) {
                    cameraYaw -= joystickRight.x * 0.1;
                    cameraPitch -= joystickRight.y * 0.05;
                }

                cameraPitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, cameraPitch));

                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraYaw;
                camera.rotation.x = cameraPitch;

                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

                const moveSpeed = 0.15;

                if (!isMobileMode && !isDetailViewOpen) {
                    if (keys['w'] || keys['arrowup']) camera.position.addScaledVector(forward, moveSpeed);
                    if (keys['s'] || keys['arrowdown']) camera.position.addScaledVector(forward, -moveSpeed);
                    if (keys['a'] || keys['arrowleft']) camera.position.addScaledVector(right, -moveSpeed);
                    if (keys['d'] || keys['arrowright']) camera.position.addScaledVector(right, moveSpeed);
                }

                if (isMobileMode && !isDetailViewOpen && joystickLeft.active) {
                    camera.position.addScaledVector(forward, -joystickLeft.y * moveSpeed);
                    camera.position.addScaledVector(right, joystickLeft.x * moveSpeed);
                }

                camera.position.x = Math.max(-18, Math.min(18, camera.position.x));
                camera.position.z = Math.max(-18, Math.min(18, camera.position.z));

                drawMinimap();
                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        init();
    </script>
</body>
</html>
